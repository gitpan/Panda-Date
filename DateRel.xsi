MODULE = Panda::Date                PACKAGE = Panda::Date
PROTOTYPES: DISABLE
#///////////////////////////// STATIC FUNCTIONS ///////////////////////////////////

DateRel *
rdate (SV* from = NULL, SV* till = NULL)
CODE:
    const char* CLASS = DATEREL_CLASS;
    if      (till) RETVAL = daterel_new(from, till);
    else if (from) RETVAL = daterel_new(from);
    else           RETVAL = new DateRel();
OUTPUT:
    RETVAL
    

DateRel *
rdate_const (SV* from = NULL, SV* till = NULL)
CODE:
    const char* CLASS = DATEREL_CLASS;
    if      (till) RETVAL = daterel_new(from, till);
    else if (from) RETVAL = daterel_new(from);
    else           RETVAL = new DateRel();
    RETVAL->isConst(true);
OUTPUT:
    RETVAL    

#///////////////////////////// OBJECT METHODS ///////////////////////////////////
MODULE = Panda::Date                PACKAGE = Panda::Date::Rel
PROTOTYPES: DISABLE

DateRel *
DateRel::new (SV* from = NULL, SV* till = NULL)
CODE:
    if      (till) RETVAL = daterel_new(from, till);
    else if (from) RETVAL = daterel_new(from);
    else           RETVAL = new DateRel();
OUTPUT:
    RETVAL


void
DateRel::set (SV* from, SV* till = NULL)
PPCODE:
    daterel_chkro(THIS);
    if (till != NULL) daterel_set(from, till, THIS);
    else daterel_set(from, THIS);


ptime_t
DateRel::sec (SV* newval = NULL)
ALIAS:
    second  = 1
    secs    = 2
    seconds = 3
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->sec(SvMIV(newval));
    }
    RETVAL = THIS->sec();
OUTPUT:
    RETVAL


ptime_t
DateRel::min (SV* newval = NULL)
ALIAS:
    mins    = 1
    minute  = 2
    minutes = 3
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->min(SvMIV(newval));
    }
    RETVAL = THIS->min();
OUTPUT:
    RETVAL


ptime_t
DateRel::hour (SV* newval = NULL)
ALIAS:
    hours = 1
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->hour(SvMIV(newval));
    }
    RETVAL = THIS->hour();
OUTPUT:
    RETVAL


ptime_t
DateRel::day (SV* newval = NULL)
ALIAS:
    days = 1
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->day(SvMIV(newval));
    }
    RETVAL = THIS->day();
OUTPUT:
    RETVAL


ptime_t
DateRel::month (SV* newval = NULL)
ALIAS:
    mon    = 1
    months = 2
    mons   = 3
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->month(SvMIV(newval));
    }
    RETVAL = THIS->month();
OUTPUT:
    RETVAL


ptime_t
DateRel::year (SV* newval = NULL)
ALIAS:
    years = 1
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->year(SvMIV(newval));
    }
    RETVAL = THIS->year();
OUTPUT:
    RETVAL


ptime_t
DateRel::to_sec ()
ALIAS:
    to_second  = 1
    to_secs    = 2
    to_seconds = 3
    duration   = 4
CODE:
    RETVAL = THIS->toSec();
OUTPUT:
    RETVAL


double
DateRel::to_min ()
ALIAS:
    to_minute  = 1
    to_mins    = 2
    to_minutes = 3
CODE:
    RETVAL = THIS->toMin();
OUTPUT:
    RETVAL


double
DateRel::to_hour ()
ALIAS:
    to_hours = 1
CODE:
    RETVAL = THIS->toHour();
OUTPUT:
    RETVAL


double
DateRel::to_day ()
ALIAS:
    to_days = 1
CODE:
    RETVAL = THIS->toDay();
OUTPUT:
    RETVAL


double
DateRel::to_month ()
ALIAS:
    to_mon    = 1
    to_months = 2
    to_mons   = 3
CODE:
    RETVAL = THIS->toMonth();
OUTPUT:
    RETVAL


double
DateRel::to_year ()
ALIAS:
    to_years = 1
CODE:
    RETVAL = THIS->toYear();
OUTPUT:
    RETVAL


const char*
DateRel::to_string (...)
ALIAS:
    as_string = 1
    string = 2
CODE:
    RETVAL = THIS->toString();
OUTPUT:
    RETVAL
    

bool
DateRel::to_bool (...)
CODE:
    RETVAL = !THIS->empty();
OUTPUT:
    RETVAL


ptime_t
DateRel::to_number (...)
CODE:
    RETVAL = THIS->toSec();
OUTPUT:
    RETVAL


DateRel*
DateRel::multiply_new (SV* arg, ...)
CODE:
    const char* CLASS = DATEREL_CLASS;
    if (!looks_like_number(arg)) croak("Panda::Date: cannot '*' on non-number");
    RETVAL = THIS->multiplyNew(SvNV(arg));
OUTPUT:
    RETVAL
    
    

SV*
DateRel::multiply (SV* arg, ...)
PPCODE:
    if (!looks_like_number(arg)) croak("Panda::Date: cannot '*' on non-number");
    daterel_chkro(THIS);
    THIS->multiply(SvNV(arg));
    XSRETURN(1);


DateRel*
DateRel::divide_new (SV* arg, bool reverse = false)
CODE:
    const char* CLASS = DATEREL_CLASS;
    if (!looks_like_number(arg)) croak("Panda::Date: cannot '/' on non-number");
    if (reverse) croak("Panda::Date: illegal divison $num/$reldate");
    RETVAL = THIS->divideNew(SvNV(arg));
OUTPUT:
    RETVAL


SV*
DateRel::divide (SV* arg, bool reverse = false)
PPCODE:
    if (!looks_like_number(arg)) croak("Panda::Date: cannot '/' on non-number");
    if (reverse) croak("Panda::Date: illegal divison $num/$reldate");
    daterel_chkro(THIS);
    THIS->divide(SvNV(arg));
    XSRETURN(1);


DateRel*
DateRel::add_new (SV* arg, ...)
CODE:
    const char* CLASS;
    DateRel* operand = NULL;
    
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else if (sv_isa(arg, DATE_CLASS)) {
            CLASS = DATE_CLASS;
            Date* date = (Date *) SvIV(SvRV(arg));
            RETVAL = (DateRel*) date->addNew(THIS);
        }
        else if (sv_isa(arg, DATEINT_CLASS)) {
            CLASS = DATEINT_CLASS;
            DateInt* idate = (DateInt *) SvIV(SvRV(arg));
            RETVAL = (DateRel*) idate->addNew(THIS);
        }
        else croak("Panda::Date: cannot '+' - unknown object type");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    
    if (operand != NULL) {
        CLASS = DATEREL_CLASS;
        RETVAL = THIS->addNew(operand);
    }
OUTPUT:
    RETVAL


SV*
DateRel::add (SV* arg, ...)
PPCODE:
    daterel_chkro(THIS);
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '+=' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }

    THIS->add(operand);
    XSRETURN(1);


DateRel*
DateRel::subtract_new (SV* arg, bool reverse = false)
CODE:
    const char* CLASS = DATEREL_CLASS;
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '-' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    
    RETVAL = reverse ? operand->subtractNew(THIS) : THIS->subtractNew(operand);
OUTPUT:
    RETVAL


SV*
DateRel::subtract (SV* arg, ...)
PPCODE:
    daterel_chkro(THIS);
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '-=' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    
    THIS->subtract(operand);
    XSRETURN(1);


DateRel*
DateRel::negative_new (...)
CODE:
    const char* CLASS = DATEREL_CLASS;
    RETVAL = THIS->negativeNew();
OUTPUT:
    RETVAL


SV*
DateRel::negative ()
PPCODE:
    daterel_chkro(THIS);
    THIS->negative();
    XSRETURN(1);


int
DateRel::compare (SV* arg, bool reverse)
CODE:
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '<=>' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    
    RETVAL = THIS->compare(operand);
    if (reverse) RETVAL = -RETVAL;
OUTPUT:
    RETVAL


bool
DateRel::equals (SV* arg, ...)
CODE:
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot 'eq' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    RETVAL = THIS->equals(operand);
OUTPUT:
    RETVAL


bool
DateRel::is_const (SV* newval = NULL)
CODE:
    if (newval) {
        daterel_chkro(THIS);
        THIS->isConst(SvTRUE(newval));
    }
    RETVAL = THIS->isConst();
OUTPUT:
    RETVAL


void
DateRel::DESTROY ()
