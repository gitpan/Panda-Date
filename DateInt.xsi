MODULE = Panda::Date                PACKAGE = Panda::Date
PROTOTYPES: DISABLE
#///////////////////////////// STATIC FUNCTIONS ///////////////////////////////////

DateInt *
idate (SV* arg1, SV* arg2 = NULL)
CODE:
    const char* CLASS = DATEINT_CLASS;
    if (arg2) RETVAL = dateint_new(arg1, arg2);
    else      RETVAL = dateint_new(arg1);
OUTPUT:
    RETVAL

#///////////////////////////// OBJECT METHODS ///////////////////////////////////
MODULE = Panda::Date                PACKAGE = Panda::Date::Int
PROTOTYPES: DISABLE

DateInt *
DateInt::new (SV* arg1, SV* arg2 = NULL)
CODE:
    if (arg2) RETVAL = dateint_new(arg1, arg2);
    else      RETVAL = dateint_new(arg1);
OUTPUT:
    RETVAL


void
DateInt::set (SV* arg1, SV* arg2 = NULL)
PPCODE:
    if (arg2) dateint_set(arg1, arg2, THIS);
    else      dateint_set(arg1, THIS);


const char*
DateInt::to_string (...)
ALIAS:
    as_string = 1
    string    = 2
CODE:
    RETVAL = THIS->toString();
OUTPUT:
    RETVAL


Date*
DateInt::from (SV* fromSV = NULL)
CODE:
    const char* CLASS = DATE_CLASS;
    if (fromSV) date_set(fromSV, NULL, THIS->from());
    RETVAL = THIS->from()->clone();
OUTPUT:
    RETVAL


Date*
DateInt::till (SV* tillSV = NULL)
CODE:
    const char* CLASS = DATE_CLASS;
    if (tillSV) date_set(tillSV, NULL, THIS->till());
    RETVAL = THIS->till()->clone();
OUTPUT:
    RETVAL


ptime_t
DateInt::sec ()
ALIAS:
    secs     = 1
    second   = 2
    seconds  = 3
    duration = 4
CODE:
    RETVAL = THIS->sec();
OUTPUT:
    RETVAL


ptime_t
DateInt::imin ()
ALIAS:
    imins    = 1
    iminute  = 2
    iminutes = 3
CODE:
    RETVAL = THIS->imin();
OUTPUT:
    RETVAL


double
DateInt::min ()
ALIAS:
    mins    = 1
    minute  = 2
    minutes = 3
CODE:
    RETVAL = THIS->min();
OUTPUT:
    RETVAL


ptime_t
DateInt::ihour ()
ALIAS:
    ihours = 1
CODE:
    RETVAL = THIS->ihour();
OUTPUT:
    RETVAL


double
DateInt::hour ()
ALIAS:
    hours = 1
CODE:
    RETVAL = THIS->hour();
OUTPUT:
    RETVAL


ptime_t
DateInt::iday ()
ALIAS:
    idays = 1
CODE:
    RETVAL = THIS->iday();
OUTPUT:
    RETVAL


double
DateInt::day ()
ALIAS:
    days = 1
CODE:
    RETVAL = THIS->day();
OUTPUT:
    RETVAL


ptime_t
DateInt::imonth ()
ALIAS:
    imon    = 1
    imons   = 2
    imonths = 3
CODE:
    RETVAL = THIS->imonth();
OUTPUT:
    RETVAL


double
DateInt::month ()
ALIAS:
    mon    = 1
    mons   = 2
    months = 3
CODE:
    RETVAL = THIS->month();
OUTPUT:
    RETVAL


ptime_t
DateInt::iyear ()
ALIAS:
    iyears = 1
CODE:
    RETVAL = THIS->iyear();
OUTPUT:
    RETVAL


double
DateInt::year ()
ALIAS:
    years = 1
CODE:
    RETVAL = THIS->year();
OUTPUT:
    RETVAL


DateRel*
DateInt::relative ()
CODE:
    const char* CLASS = DATEREL_CLASS;
    RETVAL = THIS->relative();
OUTPUT:
    RETVAL


bool
DateInt::to_bool (...)
CODE:
    RETVAL = THIS->duration() != 0;
OUTPUT:
    RETVAL


ptime_t
DateInt::to_number (...)
CODE:
    RETVAL = THIS->duration();
OUTPUT:
    RETVAL


int
DateInt::compare (SV* arg, bool reverse = false)
CODE:
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEINT_CLASS)) RETVAL = THIS->compare((DateInt *) SvIV(SvRV(arg)));
        else croak("Panda::Date: cannot '<=>' - object isn't a Panda::Date::Int object");
    }
    else if (looks_like_number(arg)) {
        RETVAL = epoch_cmp(THIS->duration(), SvIV(arg));
    }
    else {
        //static DateInt acc;
        DateInt acc;
        dateint_set(arg, &acc);
        RETVAL = THIS->compare(&acc);
    }
    
    if (reverse) RETVAL *= -1;
OUTPUT:
    RETVAL


bool
DateInt::equals (SV* arg, ...)
CODE:
    DateInt* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEINT_CLASS)) operand = (DateInt *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot 'eq' - object isn't a Panda::Date::Int object");
    }
    else {
        //static DateInt acc;
        DateInt acc;
        dateint_set(arg, &acc);
        operand = &acc;
    }
    
    RETVAL = THIS->equals(operand);
OUTPUT:
    RETVAL


int
DateInt::includes (SV* arg, bool reverse = false)
CODE:
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATE_CLASS)) RETVAL = THIS->includes((Date *) SvIV(SvRV(arg)));
        else croak("Panda::Date: cannot 'includes' - object isn't a Panda::Date object");
    }
    else {
        Date acc((ptime_t) 0);
        date_set(arg, NULL, &acc);
        RETVAL = THIS->includes(&acc);
    }
    
    if (reverse) RETVAL *= -1;
OUTPUT:
    RETVAL
    
    
DateInt*
DateInt::add_new (SV* arg, ...)
CODE:
    const char* CLASS = DATEINT_CLASS;
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '+' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    RETVAL = THIS->addNew(operand);
OUTPUT:
    RETVAL


SV*
DateInt::add (SV* arg, ...)
PPCODE:
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '+=' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }

    THIS->add(operand);
    XSRETURN(1);


DateInt*
DateInt::subtract_new (SV* arg, bool reverse = false)
CODE:
    const char* CLASS = DATEINT_CLASS;
    if (reverse) croak("Panda::Date: cannot subtract interval from something");
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '-' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }
    RETVAL = THIS->subtractNew(operand);
OUTPUT:
    RETVAL


SV*
DateInt::subtract (SV* arg, ...)
PPCODE:
    DateRel* operand;
    if (sv_isobject(arg)) {
        if (sv_isa(arg, DATEREL_CLASS)) operand = (DateRel *) SvIV(SvRV(arg));
        else croak("Panda::Date: cannot '-=' - object isn't a Panda::Date::Rel object");
    }
    else {
        static DateRel acc;
        daterel_set(arg, &acc);
        operand = &acc;
    }

    THIS->subtract(operand);
    XSRETURN(1);


DateInt*
DateInt::negative_new (...)
CODE:
    const char* CLASS = DATEINT_CLASS;
    RETVAL = THIS->negativeNew();
OUTPUT:
    RETVAL


DateInt*
DateInt::negative ()
PPCODE:
    THIS->negative();
    XSRETURN(1);


void
DateInt::DESTROY ()
